#include <iostream>
//#include <stdio.h>
using namespace std;

//内联函数
//概念:以inline修饰的函数叫做内联函数，编译时c++编译器会在调用内联函数的地方
//展开，此时没有函数压栈的开销就是不会建立栈帧，可以提升程序的运行效率
//c语言为了小函数避免建立栈帧的消耗，-》提供了宏函数支持，预处理阶段展开
//既然c语言已经解决了，为什么c++还要提供inline函数呢(宏函数的缺点)重点
//a:不支持调试   b:宏函数语法复杂，容易出错  c:没有类型安全检查
//#define add(x , y) ((x) + (y))
//#define add(x , y) x + y//这里会涉及优先级的问题

//C++推荐频繁使用的小函数，定义位内联函数(inline)，会在调用的地方展开，没有栈帧开销

//不能所有函数都使用内联函数的原因:
//假如定义一个sort()函数有一百行指令
//如果不用内联函数则如果有十个调用他的地方会总计110条指令(命令多少并不代表效率高低)
//而如果使用内联函数则会在每次调用的地方进行展开所以总计会有1000条指令
//指令变多就意味着编译出来的可执行程序变大，执行程序内存消耗变多，软件使用者体验变差

//最后总结:
//1.内联是一种以空间换时间的做法，省去调用函数开销，所以代码很长或者有循环递归的函数
//不宜使用作为内联函数。

//2.inline函数对于编译器而言只是一个建议，编译器会自动优化，如果定义位inline
//的函数体内有递归等语句，编译器优化的时候会自动忽略内联函数

//3.inline不建议声明和定义分离，分离会导致链接错误，因为inline被展开，就没有
//函数地址了，链接就会找不到

inline int add(int a, int b)
{
	return a + b;
}
//int main()
//{
//	int a = 10;
//
//	//在语法上，这里是给a这块空间取一个别名，没有新开空间
//	int& ra = a;
//	ra = 20;
//
//	//在语法上，这是是定义一个pa指针变量，开了四个字节来存储a的地址
//	int* pa = &a; 
//	*pa = 20;
//	//这里引用没有开空间，指针需要开空间只是在语法层的方面，但在物理层方面
//	//引用也是需要运用指针的
//	return 0;
//
//}

//自动指针auto
//auto是不能用来作为形参的 void add(auto x)这种是不行的
//auto是不能进行修饰数组的 auto a[10] = {1 , 2 , 3};//也是不行的
//int main()
//{
//	int x = 10;
//
//	auto a = &x;//此时auto表示的是int*
//	auto* b = &x;//此时auto表示的也是int*
//	int& y = x;//此时y的类型就是int
//	auto c = y;//此时auto表示的是int
//	//auto a = 1, b = 4.0; 这种语句是不可以的，auto不可以同时修饰两个不同的类型
//	cout << typeid(x).name() << endl;
//	//上面的这个函数表示的是输出变量x的类型
	//int arr[] = { 1, 2, 3 };
//	//c++11新语法遍历
//	//范围for，新语法更简单，数组都可以
//	//自动遍历，以此取出arr中的元素，赋值给e知道结束
//	//如果想通过自动遍历来改变数组中的数值则需要
	//for (auto& ee : arr)
	//{//要进行引用操作
	//	ee *= 2;
	//}//这时在后面打印的时候就会变为原来的二倍
	//int arr[] = { 1, 2, 3 };
	//for (auto e : arr)
	//{
	//	cout << e << endl;
	//}
//	//void TTs(int arr[])这是参数并不是一个数组而是数组的首地址，所以不能进行auto遍历
//	
//	//在c++11中补缺了NULL的缺陷，在c++11中使用的是nullptr
//	//因为在c++中是使用宏定义进行定义NULL(#define NULL 0)
//	//所以这个时候NULL就不是一个指针变量了，而是会自动变为数值0
//	//所以c++11中使用nullptr这个是正经的空指针
//	
//	
//	return 0;
//
//}

//面向对象和面向过程
//C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题
//C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成

//定义一个类
//类由两部分构成:1.成员变量(属性) 2.成员函数(做的行为)
//C++中的struct兼顾C的所有用法，同时C++也把struct升级为类
//类中有三个访问限定符:私有(private),保护(protected),公有(public)
//当在类中没有写的时候class的默认访问符是私有的
//在struct中没有写的时候其默认的访问符是共有的
//所以在类设计中一般情况下，想给别人访问的定义为公有(public)，不想给别人访问的设计为私有(private)

//面向对象三大特性：封装，继承，多态
//1.封装 本质就是一种管理:
//封装是将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开
//接口来和对象进行交互
class Sss
{
private:
	int a, b;
	double c;//此处只是对a，b，c的一个声明
	
public:
	//类中的函数可以在类中声明并定义，也可以在类中声明在外面定义如:
	int add(int a, int b);//此时函数在类中进行声明
	
	int mul(int a, int b)
	{
		return a - b;//此时就是在类中进行声明并进行了定义
	}
};

int Sss::add(int a, int b)//在外面进行定义
{
	return a + b;
}//此时要指出这个add是从哪个类中来的

//只存在成员函数的类
class A2
{
public:
	void f2(){}
};

//空类
class A3
{};

int main()
{
	Sss s;//在这里创建一个对象的时候才是对类中成员变量的一种定义
	//声明的时候还没有开给成员变量开空间，在定义的时候给成员变量开空间
	cout << sizeof(s) << endl;//这是要内存对齐，而且在类中对象大小的计算
	//的时候只考虑成员变量的大小，不考虑成员函数的大小，成员函数存在公共的代码
	//段，因为每个对象调用的都是一个函数地址，所以如果算在对象的大小中会造成
	//空间的浪费。
	A2 a;
	cout << sizeof(a) << endl;
	
	A3 b;
	cout << sizeof(b) << endl;
	//这时的a对象和b对象中都没有成员变量，但是这个时候其对象的大小并不是0
	//而是1原因为:
	//给一个字节不是为了存储数据，而是为了占位，表示这些对象存在过
	//不给空间怎么表示对象存在过
	return 0;
}
