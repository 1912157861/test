#include <iostream>

using namespace std;

//内存对齐可以提高访问效率

class Date
{//这个类的限定符防的是在类外进行调用而不防类内调用，类内可以随便调用成员变量
public:
	//在下面的函数中编译器会自动加一个指针参数Init(Date* this , int ....)
	//所以实际上
	void Init(int year, int month, int day)
	{//这里的两个year会根据就近原则优先访问近的，所以会自己赋值给自己
		//year = year;//此时要是成员函数在上面，这时候会取就近原则
		_year = year;
		_month = month;
		_day = day;

		//this指针是存在栈上的，毕竟this是一个形参，但是不同的编译器不一样
		this->_year = year;
		this->_month = month;
		this->_day = day;//这种写法和上面的写法的作用是一样的，都是赋值
	}//就是这里赋值的不是成员变量year

private://凡是成员变量，建议命名风格区分一下
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;
	d1.Init(2021, 5, 20);

	//所以这两个调用语句实际上在编译器中是Init(&d1, 2021, 5, 20)
	//这里就隐含了一个参数，隐含的就是对象的地址，这样就可以分辨成员变量是谁的
	//而且这个参数是隐含的，是编译器自动加的，我们定义函数的时候不能写出来
	//但是可以在成员函数中使用this指针，这个this就是使用的对象的地址。
	Date d2;
	d2.Init(2021, 5, 21);
	return 0;

}

class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}

	void Show()
	{
		cout << "Show()" << endl;
	}

private:
	int _a;
};
//
//int main()
//{//此时代码的编译不会出错，但是运行的时候会报错
//	A* p = nullptr;//此时定义一个空指针
//	p->PrintA();//报错会在此处报错，这里PrintA()里面编译器会加一个Date* p
//	//并且PrintA()函数中存在成员变量，而成员变量是存储在对象中的，而这时p是个
//	//空指针，所以会报错。
//	p->Show();//此处不会报错，是因为在Show()函数中没有使用成员变量，也就是
//	//说参数中的Date* p是没有被使用的，且Show()函数的地址也不是存储在成员中
//	//的所以与你成员是否是空没有关系，所以这个Show()函数不会报错。
//
//	return 0;
//}

//当类中没有成员函数中，编译器会自动生成六个函数，这六个函数就叫默认(缺省)成员函数

//1.构造函数 --> 对象的初始化
//构造函数的特性: 1.函数名和类型相同
//				2.无返回值
//				3.对象实例化的时候编译器会自动调用对应的构造函数(保证对象一定会初始化)
//				4.构造函数可以重载 

class A
{
private:
	int _aa;
public:
	A(int a = 0)
	{
		_aa = a;
	}

	void Print()
	{
		cout << _aa << endl;
	}
};
class Date
{
private:
	int _year;
	int _month;
	int _day;
	A _aa;//这里_aa为自定义函数，编译器会对其进行默认初始化

public:
	//这里如果我们不写构造函数，编译器就会自动生成一个构造函数Date(){}
	//如果我们写了的话则编译器就不会生成构造函数了
	Date(int year , int month = 1, int day = 1)
	{//这里可以把构造函数弄成全缺省的函数，这样写一个就ok了
		_year = year;
		_month = month;
		_day = day;
	}

	Date()
	{
		_year = 0;
		_month = 1;
		_day = 1;
	}

	void Print()
	{
		cout << _year << '-' << _month << '-' << _day << endl;
	}
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
};

//默认构造函数:当我们不写构造函数得时候编译器默认生成得构造函数是其中一个但是不全面
//1.我们不写编译器默认生成的
//2.我们自己写的无参的
//3.我们自己写的全缺省的(不能和自己写的无参的函数同时存在)
//总结:不用参数就可以调用的函数就是默认构造函数
//上面这三种默认构造函数中全缺省函数是最好的默认构造函数

int main()
{
	Date d1(2021 , 5 , 21);
	d1.Print();

	Date d2; 
	d2.Print();
	return 0;

}


//析构函数
//析构函数与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由
//编译器完成的，而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作‘

//析构函数的特性
//析构函数是个特殊的函数
//1.析构函数名时在类名前加上字符~。
//2.无参数无返回值。(表示析构函数不能进行重载，也就是只有一个)
//3.一个类有且仅有一个析构函数，若未显示定义，系统会自动生成默认的析构函数。
//4.对象的声明周期结束时，C++编译系统自动调用析构函数。

class Date
{
private:
	int _year;
	int _month;
	int _day;
public:
	//此处不写析构函数，编译器也会自动生成一个
	~Date()//析构函数
	{//出了作用域就会调用析构函数
		//用于资源的清理
	}

};

class A
{
private:
	int a, b;
	Date d2;//这里自定义类型函数会自动调用他的析构函数
public:


};

//数据结构中的栈和堆和内存分段区域中的栈和堆，他们之间有什么区别和联系？
//1.他们之间没有绝对的关系，因为他们属于两个学科的各自的一些命名
//2.数据结构栈和系统分段栈(函数栈帧)中都满足后进先出的规则
int main()
{
	Date d1;
	Date d2;//创建这两个对象
	//因为这两个对象是在栈帧中，而这个栈帧是后进先出的
	//所以这个时候析构函数会先销毁d2，再销毁d1
}
