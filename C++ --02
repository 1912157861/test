#include <iostream>

using namespace std;
//编译链接的过程
// 1.预处理 -- 头文件展开 + 宏替换 + 去掉注释 + 条件编译
// f.i main.i

// 2.编译 -- 检查语法，生成汇编代码（此处只要有函数的声明编译就可以被过了）
// f.s main.s     此时会认为函数的声明在其他地方，在链接的时候再去找函数的地址

// 3.汇编 -- 把汇编代码转成二进制的机器码(就像翻译的过程，让cpu可以认识的代码)
// f.o main.o

// 4.链接 -- 链接到一起生成可执行程序
// a.out 

extern "C" int add(int a, int b);

int add(int a, int b)//返回的是对象c的拷贝
{
	return a + b;
}

int add(int a, int b, int c)
{
	return a + b + c;
}

//利用引用传参，传返回值可以提高速率并且避免深拷贝问题。
int& Adds(int a, int b)//返回的是对象c的引用
{//此时返回的是地址，返回的时c的地址
	//此时要是带上静态就可以做引用返回了
	static int c = a + b;//此时c就在内存中的静态区了，而不在栈中了
	return c;//所以此时调用函数就不会对其值进行影响
}//实际上，如果出了函数作用域，返回对象不存在了，不能用引用返回

//c语言不支持重载但是c++支持重载的原因:
//c语言是不支持重载的
//因为在内存中c语言在符号表中直接把函数名作为名字,所以只要函数名字相同就会报错,例如上面的函数用c语言在符号表中表示为_add
//c++支持函数重载
//因为在内存中c++在符号表中是函数的名字于参数一起作为名字(比如上面的add函数在符号表中会被表示为_Z3addii)
//此处的ii表示的是add这个函数中的参数的类型是两个整数型,如果是两个小数形式那么这个函数在符号表中会被表示为
//_Z3adddd,所以c++就是通过将名字中加入函数的参数来支持重载的

//c++有一些东西是c语言用不了的，extern是用来解决将c++的部分东西可以以c语言的方式进行编译
extern "C" int Add(int a, int b);
//上面的语句是用来表示Add函数可以用c语言规则来进行编译

int main()
{
	//越界是不一定报错的
	//有的时候编译器会在数组的后面给一些检查位,也就是会给这些越界位置的值
	//数组在函数结束的时候会对一些检查位的数值进行检查,如果数值变了就会报错
	int a = 10;
	//引用(引用的权限是可读可写的)
	int& b = a;//此时b就是a的别名
	//int& c;此时定义引用c是错误的,引用必须要初始化
	//int& c = NULL;这样也是不行的,引用不能指向空

	int c = 20;
	b = c;//此时指的是将c的值赋值给b,引用初始化之后不会改变,只会改变访问空间的值，而空间是不变的	
	
	//常引用
	const int s = 10;
	//int& ra = s;(属于权限的放大)此时s是一个常量，是不可以改变的，也就是不能定义一个别名来修改他的值
	const int& ra = s;//此时就可以了，这是就是代表s的引用ra来读他但是不修改他的值，这样是可以的
	const int& t = a;//(属于权限缩小)此时表示t作为a的别名只读他的权限，只访问他的空间而不改变他的值
	
	int m = 10;
	double n = 11.1;
	n = m; //隐式类型转换是可以的 , 会先将m给一个double类型的临时变量，再将临时变量的只赋值给n

	const double& rc = c;//此时会有一个double的临时变量，临时变量具有常性不能更改
	//只要是这种类型不同就会发生隐式类型转换，而且这时rc不是对c的别名而是对c产生的double类型的临时变量的别名
	//所以此时改变c是不能改变rc的
	int k = 10, r = 20;
	//int& rd = add(k, r);
	//此时上面的语法是错误的，因为在调用函数的时候要先将函数中返回的值赋值到
	//一个临时变量中的，这个临时变量具有常性的就是不能被更改的,所以做这个函数
	//的引用要用常引用，如下面的语句

	const int& rd = add(k, r);//这样进行常引用就是正确的，此时的引用的值只能读不能更改
	int& sb = Adds(k, r);//此时表示s指向的是Adds函数中返回的c的地址
	//也就是说s和c指向的是同一块地址
	Adds(10, 20);//调用同一个函数访问的是同一个地址,函数调用结束其栈帧就被销毁了
	printf("hello world\n");//此时如果调用输出语句的化则sb的值就是变为随机值
	cout << sb << endl;//此时调用了两次Adds，所以sb指向的空间的值是30
	//栈在创建空间中是向下生长，堆在创建空间中是向上生长的
	//在内存空间中高地址在上，低地址在下。
	//栈每开一次空间都会向下开辟空间，也就是说越往后开辟的空间的地址越小
	//而堆每开一次空间都会向上开辟空间，也就是说越往后开辟的空间地址越大
	//而且比如上面的sb指向的c的空间，如果Adds函数被销毁之后，sb指向的空间不变
	//而下一次调用函数的时候，这个调用的函数所访问的空间就还是之前被收回的空间
	
	return 0;

}
